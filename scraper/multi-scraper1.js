require('dotenv').config();
const fs = require('fs');
const path = require('path');
const puppeteer = require('puppeteer');
const db = require('./db');
const axios = require('axios');
const { exec } = require('child_process');
const { formatMessage } = require('../api/notify');

const productsPerPage = 36;
const outputDir = path.join(__dirname, 'products');
const PAGE_TIMEOUT = 45000; // 45 saniye
const GLOBAL_TIMEOUT = 1800000; // 30 dakika
const RETRY_COUNT = 3; // Sayfa y√ºkleme ba≈üarƒ±sƒ±z olursa 3 kez dene
const DELAY_BETWEEN_PAGES = 2000; // Sayfalar arasƒ± minimum bekleme s√ºresi
const DELAY_BETWEEN_CATEGORIES = 30000; // Kategoriler arasƒ± bekleme s√ºresi (30 saniye)
const SCAN_INTERVAL = 900000; // Taramalar arasƒ± bekleme s√ºresi (15 dakika)

// Log kaydetme fonksiyonu
async function saveLog(categorySlug, message, type = 'info') {
  try {
    // √ñnce log sayƒ±sƒ±nƒ± kontrol et
    const countResult = await db.query('SELECT COUNT(*) FROM logs');
    const logCount = parseInt(countResult.rows[0].count);

    // Eƒüer log sayƒ±sƒ± 100'√º ge√ßtiyse, en eski kaydƒ± sil
    if (logCount >= 100) {
      await db.query('DELETE FROM logs WHERE id = (SELECT id FROM logs ORDER BY created_at ASC LIMIT 1)');
    }

    // Yeni logu kaydet
    await db.query(
      'INSERT INTO logs (category_slug, message, type) VALUES ($1, $2, $3)',
      [categorySlug, message, type]
    );
  } catch (error) {
    console.error('Log kaydedilirken hata:', error);
  }
}

// Telegram bildirim fonksiyonu
async function sendTelegramMessage(message) {
  try {
    const botToken = process.env.TELEGRAM_BOT_TOKEN;
    const chatId = process.env.TELEGRAM_CHAT_ID;
    
    if (!botToken || !chatId) {
      console.error('‚ùå Telegram bot token veya chat ID bulunamadƒ±!');
      return;
    }

    const url = `https://api.telegram.org/bot${botToken}/sendMessage`;
    await axios.post(url, {
      chat_id: chatId,
      text: message,
      parse_mode: 'HTML'
    });
  } catch (error) {
    console.error('‚ùå Telegram mesajƒ± g√∂nderilirken hata:', error.message);
  }
}

// üß† Veritabanƒ±ndan kategorileri al
async function loadCategoriesFromDB() {
  const result = await db.query('SELECT * FROM categories ORDER BY id');
  return result.rows;
}

// √úr√ºn linkini temizle
function cleanProductLink(link) {
  try {
    const redirectMatch = link.match(/redirect=([^&]+)/);
    if (redirectMatch) {
      return decodeURIComponent(redirectMatch[1]);
    }
    return link;
  } catch (e) {
    return link;
  }
}

// üîç Bir kategoriyi ba≈ütan sona tara
async function scrapeCategory(category, browser) {
  const startTime = Date.now();
  const baseURL = category.url.split('?')[0];
  const slug = category.slug;
  let retryCount = 0;
  const MAX_RETRIES = 3;

  console.log('\n' + '='.repeat(50));
  console.log(`üîç ${category.title} kategorisi taranƒ±yor...`);
  console.log('='.repeat(50) + '\n');

  while (retryCount < MAX_RETRIES) {
    try {
      const page = await browser.newPage();
      
      // Bot tespitini √∂nlemek i√ßin geli≈ümi≈ü ayarlar
      await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
      await page.setExtraHTTPHeaders({
        'Accept-Language': 'tr-TR,tr;q=0.9,en-US;q=0.8,en;q=0.7',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
        'sec-ch-ua': '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-platform': '"Windows"',
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache'
      });

      // Tarama hƒ±zƒ±nƒ± d√º≈ü√ºr
      await page.setDefaultNavigationTimeout(PAGE_TIMEOUT);
      await page.setDefaultTimeout(PAGE_TIMEOUT);

      // Her istek √∂ncesi rastgele gecikme
      await page.setRequestInterception(true);
      page.on('request', async (request) => {
        const delay = Math.random() * 2000 + 1000; // 1-3 saniye arasƒ±
        await new Promise(resolve => setTimeout(resolve, delay));
        request.continue();
      });

      const allProducts = [];

      // Sayfa y√ºkleme fonksiyonu
      async function loadPage(url, retryCount = 0) {
        try {
          // Rastgele gecikme ekle (2-4 saniye)
          const delay = Math.floor(Math.random() * 2000) + 2000;
          await new Promise(resolve => setTimeout(resolve, delay));

          await page.goto(url, { 
            waitUntil: 'networkidle2',
            timeout: PAGE_TIMEOUT 
          });
          
          // Sayfa y√ºklendikten sonra ek bekleme (2-3 saniye)
          const postDelay = Math.floor(Math.random() * 1000) + 2000;
          await new Promise(resolve => setTimeout(resolve, postDelay));
          
          return true;
        } catch (error) {
          if (retryCount < RETRY_COUNT) {
            const message = `‚ö†Ô∏è Sayfa y√ºklenemedi, ${retryCount + 1}. deneme yapƒ±lƒ±yor...`;
            console.log(message);
            await page.waitForTimeout(5000);
            return loadPage(url, retryCount + 1);
          }
          throw error;
        }
      }

      // ƒ∞lk sayfayƒ± a√ß
      console.log(`üåê ${category.title} - ƒ∞lk sayfa y√ºkleniyor...`);
      await loadPage(baseURL);

      // Sayfanƒ±n y√ºklenmesini bekle
      await page.waitForSelector('div[class^="VZbTh5SU1OsNkwSvy5FF"]', { timeout: PAGE_TIMEOUT });

      // Toplam √ºr√ºn sayƒ±sƒ±nƒ± al
      const totalText = await page.$eval(
        'div[class^="VZbTh5SU1OsNkwSvy5FF"]',
        (el) => el.textContent.trim()
      );
      const totalProducts = parseInt(totalText.match(/\d+/)[0]) || 0;
      const totalPages = Math.ceil(totalProducts / productsPerPage);

      console.log(`\nüìä ${category.title} kategorisi bilgileri:`);
      console.log(`   ‚Ä¢ Toplam √ºr√ºn sayƒ±sƒ±: ${totalProducts}`);
      console.log(`   ‚Ä¢ Toplam sayfa sayƒ±sƒ±: ${totalPages}`);
      console.log('   ‚Ä¢ Sayfa ba≈üƒ±na √ºr√ºn: ' + productsPerPage + '\n');

      // ƒ∞lk sayfadaki √ºr√ºnleri al
      console.log(`üì• Sayfa 1/${totalPages} taranƒ±yor...`);
      let firstPageProducts = await page.evaluate(() => {
        const items = [];
        document.querySelectorAll('li[class^="productListContent-"]').forEach((el) => {
          const titleEl = el.querySelector('h2[class^="title-module_titleRoot"] span');
          const priceEl = el.querySelector('div[class^="price-module_finalPrice"]');
          const linkEl = el.querySelector('a[class^="productCardLink-module"]');

          const title = titleEl?.innerText.trim();
          const price = priceEl?.innerText.trim();
          const link = linkEl?.getAttribute('href');
          let image = null;
          // √ñncelik sƒ±rasƒ±: √∂zel class'lƒ± img, kart i√ßindeki ilk img, ilk source srcset
          const imageEl = el.querySelector('img.hbImageView-module_hbImage__Ca3xO') || el.querySelector('img');
          if (imageEl && imageEl.getAttribute('src')) {
            image = imageEl.getAttribute('src');
          } else {
            const sourceEl = el.querySelector('source') || el.querySelector('source.hbImageView-module_hbImage__Ca3xO');
            if (sourceEl && sourceEl.getAttribute('srcset')) {
              image = sourceEl.getAttribute('srcset').split(',')[0].split(' ')[0];
            } else {
              // Fallback: data-src veya style background-image
              const dataSrc = el.querySelector('[data-src]');
              if (dataSrc) {
                image = dataSrc.getAttribute('data-src');
              } else if (el.style && el.style.backgroundImage) {
                const bg = el.style.backgroundImage.match(/url\(["']?(.*?)["']?\)/);
                if (bg && bg[1]) image = bg[1];
              }
            }
          }
          if (title && price && link) {
            items.push({
              title,
              price,
              link: 'https://www.hepsiburada.com' + link,
              image
            });
          }
        });
        return items;
      });
      // Node.js tarafƒ±nda image null olanlarƒ± logla
      firstPageProducts.forEach(p => { if (!p.image) console.log('[NODE G√ñRSEL LOG] G√∂rsel yok:', p.title, p.link); });
      // Linkleri temizle
      firstPageProducts = firstPageProducts.map(p => {
        const link = cleanProductLink(p.link);
        // HB ile ba≈ülayan kodu linkten √ßek
        const codeMatch = link.match(/(HB[A-Z0-9]+)/);
        return { ...p, link, product_code: codeMatch ? codeMatch[1] : null };
      });

      allProducts.push(...firstPageProducts);
      console.log(`‚úÖ Sayfa 1: ${firstPageProducts.length} √ºr√ºn tarandƒ±`);

      // Diƒüer sayfalarƒ± tara
      for (let pageNum = 2; pageNum <= totalPages; pageNum++) {
        // Global timeout kontrol√º
        if (Date.now() - startTime > GLOBAL_TIMEOUT) {
          const message = `Global timeout (${GLOBAL_TIMEOUT/1000} saniye) a≈üƒ±ldƒ±`;
          console.error(message);
          throw new Error(message);
        }

        const url = `${baseURL}?sayfa=${pageNum}`;
        console.log(`\nüì• Sayfa ${pageNum}/${totalPages} taranƒ±yor...`);

        // Sayfalar arasƒ± minimum bekleme s√ºresi
        await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_PAGES));
        
        await loadPage(url);

        let pageProducts = await page.evaluate(() => {
          const items = [];
          document.querySelectorAll('li[class^="productListContent-"]').forEach((el) => {
            const titleEl = el.querySelector('h2[class^="title-module_titleRoot"] span');
            const priceEl = el.querySelector('div[class^="price-module_finalPrice"]');
            const linkEl = el.querySelector('a[class^="productCardLink-module"]');

            const title = titleEl?.innerText.trim();
            const price = priceEl?.innerText.trim();
            const link = linkEl?.getAttribute('href');
            let image = null;
            // √ñncelik sƒ±rasƒ±: √∂zel class'lƒ± img, kart i√ßindeki ilk img, ilk source srcset
            const imageEl = el.querySelector('img.hbImageView-module_hbImage__Ca3xO') || el.querySelector('img');
            if (imageEl && imageEl.getAttribute('src')) {
              image = imageEl.getAttribute('src');
            } else {
              const sourceEl = el.querySelector('source') || el.querySelector('source.hbImageView-module_hbImage__Ca3xO');
              if (sourceEl && sourceEl.getAttribute('srcset')) {
                image = sourceEl.getAttribute('srcset').split(',')[0].split(' ')[0];
              } else {
                // Fallback: data-src veya style background-image
                const dataSrc = el.querySelector('[data-src]');
                if (dataSrc) {
                  image = dataSrc.getAttribute('data-src');
                } else if (el.style && el.style.backgroundImage) {
                  const bg = el.style.backgroundImage.match(/url\(["']?(.*?)["']?\)/);
                  if (bg && bg[1]) image = bg[1];
                }
              }
            }
            if (title && price && link) {
              items.push({
                title,
                price,
                link: 'https://www.hepsiburada.com' + link,
                image
              });
            }
          });
          return items;
        });
        // Node.js tarafƒ±nda image null olanlarƒ± logla
        pageProducts.forEach(p => { if (!p.image) console.log('[NODE G√ñRSEL LOG] G√∂rsel yok:', p.title, p.link); });
        // Linkleri temizle
        pageProducts = pageProducts.map(p => {
          const link = cleanProductLink(p.link);
          // HB ile ba≈ülayan kodu linkten √ßek
          const codeMatch = link.match(/(HB[A-Z0-9]+)/);
          return { ...p, link, product_code: codeMatch ? codeMatch[1] : null };
        });

        allProducts.push(...pageProducts);
        console.log(`‚úÖ Sayfa ${pageNum}: ${pageProducts.length} √ºr√ºn tarandƒ±`);
      }

      await page.close();

      // Dosyaya yazmadan √∂nce t√ºm √ºr√ºnlerin linkini temizle
      const cleanedProducts = allProducts.map(p => ({ ...p, link: cleanProductLink(p.link) }));

      // Dosyaya yaz
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      const outputPath = path.join(outputDir, `${slug}.json`);
      const previousPath = path.join(outputDir, `${slug}_previous.json`);

      // Fiyat deƒüi≈üikliklerini ve yeni √ºr√ºnleri kontrol et
      let priceChanges = 0;
      let newProducts = 0;
      let changedProducts = [];
      let newProductList = [];
      
      // √ñnceki verileri oku
      let previousProducts = [];
      let isFirstScan = false;
      if (fs.existsSync(previousPath)) {
        try {
          previousProducts = JSON.parse(fs.readFileSync(previousPath, 'utf8'));
        } catch (e) {
          console.log('‚ö†Ô∏è √ñnceki veriler okunamadƒ±, yeni dosya olu≈üturuluyor.');
        }
      } else {
        isFirstScan = true;
      }

      // √ñnceki √ºr√ºnleri map'e √ßevir (√∂ncelik √ºr√ºn kodu, yoksa link)
      const previousMap = new Map();
      for (const p of previousProducts) {
        if (p.product_code) {
          previousMap.set(p.product_code, p);
        } else if (p.link) {
          previousMap.set(p.link, p);
        }
      }

      // Deƒüi≈üiklikleri kontrol et
      for (const newProduct of cleanedProducts) {
        const key = newProduct.product_code || newProduct.link;
        const oldProduct = previousMap.get(key);
        if (!oldProduct) {
          newProducts++;
          newProductList.push(newProduct);
        } else {
          // Eƒüer eski kayƒ±tta g√∂rsel yok ama yenisinde varsa, eski kaydƒ± g√ºncelle ama bildirim g√∂nderme
          let updated = false;
          if ((!oldProduct.image || oldProduct.image === '-') && newProduct.image && newProduct.image !== '-') {
            oldProduct.image = newProduct.image;
            updated = true;
          }
          // Diƒüer alanlar i√ßin de benzer g√ºncelleme yapƒ±labilir (√∂r: title, price vs.)
          // Eƒüer sadece g√ºncelleme olduysa, yeni √ºr√ºn bildirimi g√∂nderme
          if (updated) {
            continue;
          }
          // Fiyat deƒüi≈üikliƒüini kontrol et
          const oldPrice = parseFloat(oldProduct.price.replace(/[^0-9,]/g, '').replace(',', '.'));
          const newPrice = parseFloat(newProduct.price.replace(/[^0-9,]/g, '').replace(',', '.'));
          
          // Sadece fiyat d√º≈ü√º≈ülerini kontrol et
          if (newPrice < oldPrice) {
            // Kategori i√ßin e≈üik deƒüerini kontrol et
            const priceChange = ((oldPrice - newPrice) / oldPrice) * 100;
            if (priceChange >= category.discount_threshold) { // Kategori bazlƒ± e≈üik deƒüeri
              priceChanges++;
              changedProducts.push({
                old: oldProduct,
                new: newProduct,
                changePercentage: priceChange.toFixed(2)
              });
            }
          }
        }
      }

      // Yeni verileri kaydet
      fs.writeFileSync(outputPath, JSON.stringify(cleanedProducts, null, 2), 'utf8');
      
      // √ñnceki verileri g√ºncelle
      fs.writeFileSync(previousPath, JSON.stringify(cleanedProducts, null, 2), 'utf8');

      console.log('\nüìä Tarama Sonu√ßlarƒ±:');
      console.log(`   ‚Ä¢ Toplam taranan √ºr√ºn: ${cleanedProducts.length}`);
      console.log(`   ‚Ä¢ Fiyat deƒüi≈üikliƒüi: ${priceChanges} √ºr√ºn`);
      console.log(`   ‚Ä¢ Yeni √ºr√ºn: ${newProducts} √ºr√ºn`);

      if (!isFirstScan && (priceChanges > 0 || newProducts > 0)) {
        console.log('\nüîî Bildirim g√∂nderiliyor...');
        try {
          // Fiyat deƒüi≈üikliƒüi olan √ºr√ºnler i√ßin bildirim
          if (priceChanges > 0) {
            for (const change of changedProducts) {
              const formatted =
                `üí∏ Fiyatƒ± g√ºncellenen √ºr√ºn: ${change.new.title}\n` +
                `üì¶ √úr√ºn Kodu: ${change.new.product_code || '-'}\n` +
                `üñºÔ∏è G√∂rsel: ${change.new.image || '-'}\n` +
                `üìà Eski fiyat: ${change.old.price}\n` +
                `üìä Yeni fiyat: ${change.new.price}\n` +
                `‚ö°Ô∏è E≈üik deƒüeri: %${category.discount_threshold}\n\n` +
                `ƒ∞ndirim oranƒ±: %${change.changePercentage}\n` +
                `üîó ${change.new.link}`;
              await saveLog(slug, formatted, 'price_change');
              await sendTelegramMessage(formatted);
            }
          }
          // Yeni √ºr√ºnler i√ßin bildirim
          if (newProducts > 0) {
            for (const product of newProductList) {
              const formatted = formatMessage({
                type: 'new',
                title: product.title,
                price: product.price,
                link: product.link,
                productCode: product.product_code,
                imageUrl: product.image,
              });
              await saveLog(slug, formatted, 'new_product');
              await sendTelegramMessage(formatted);
            }
          }
          console.log('‚úÖ Bildirimler g√∂nderildi');
        } catch (error) {
          console.error('‚ùå Bildirim g√∂nderilirken hata:', error.message);
        }
      }

      console.log('\n' + '='.repeat(50));
      console.log(`‚úÖ ${category.title} kategorisi taramasƒ± tamamlandƒ±`);
      console.log('='.repeat(50) + '\n');

      // Tarama bittikten sonra kategori bekleme s√ºresi
      console.log(`\n‚è≥ ${category.title} kategorisi i√ßin ${DELAY_BETWEEN_CATEGORIES/1000} saniye bekleniyor...`);
      await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_CATEGORIES));

      return true;
    } catch (error) {
      retryCount++;
      console.error(`\n‚ö†Ô∏è ${category.title} kategorisi taranƒ±rken hata olu≈ütu (Deneme ${retryCount}/${MAX_RETRIES}):`, error.message);
      
      if (retryCount < MAX_RETRIES) {
        console.log(`üîÑ ${category.title} kategorisi yeniden deneniyor...`);
        await new Promise(resolve => setTimeout(resolve, 10000)); // 10 saniye bekle
        continue;
      }
      
      console.error(`\n‚ùå ${category.title} kategorisi ${MAX_RETRIES} deneme sonunda ba≈üarƒ±sƒ±z oldu.`);
      return false;
    }
  }
}

// üîÅ T√ºm kategorileri paralel olarak tara
async function scrapeAll() {
  const startTime = Date.now();
  const categories = await loadCategoriesFromDB();
  
  console.log('\n' + '='.repeat(50));
  console.log('üöÄ Hepsiburada Fiyat Takip Sistemi Ba≈ülatƒ±lƒ±yor');
  console.log('='.repeat(50));
  console.log(`\nüìã Toplam ${categories.length} kategori taranacak\n`);

  let successCount = 0;
  let failCount = 0;
  let totalProducts = 0;

  // Tek browser ba≈ülat
  const browser = await puppeteer.launch({ 
    headless: 'new',
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });

  // Kategorileri sƒ±rayla tara
  for (let i = 0; i < categories.length; i++) {
    // Global timeout kontrol√º
    if (Date.now() - startTime > GLOBAL_TIMEOUT) {
      const message = `\nüõë Global timeout (${GLOBAL_TIMEOUT/1000} saniye) a≈üƒ±ldƒ±. ƒ∞≈ülem durduruluyor.`;
      console.error(message);
      break;
    }

    const category = categories[i];
    console.log(`\nüîÑ ${category.title} kategorisine ge√ßiliyor...`);

    const success = await scrapeCategory(category, browser);
    if (success) {
      successCount++;
      const outputPath = path.join(outputDir, `${category.slug}.json`);
      if (fs.existsSync(outputPath)) {
        const products = JSON.parse(fs.readFileSync(outputPath, 'utf8'));
        totalProducts += products.length;
      }
    } else {
      failCount++;
    }

    // Kategoriler arasƒ± rastgele bekleme
    if (i < categories.length - 1) {
      const delay = Math.floor(Math.random() * 3000) + 2000; // 2-5 saniye
      console.log(`\n‚è≥ Sonraki kategori i√ßin ${delay/1000} saniye bekleniyor...\n`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  // Browser'ƒ± kapat
  await browser.close();

  const duration = ((Date.now() - startTime) / 1000).toFixed(1);
  
  console.log('\n' + '='.repeat(50));
  console.log('üìä TARAMA SONU√áLARI');
  console.log('='.repeat(50));
  console.log(`\n‚úÖ Ba≈üarƒ±lƒ±: ${successCount} kategori`);
  console.log(`‚ùå Ba≈üarƒ±sƒ±z: ${failCount} kategori`);
  console.log(`üì¶ Toplam taranan √ºr√ºn: ${totalProducts}`);
  console.log(`‚è±Ô∏è Toplam s√ºre: ${duration} saniye`);
  console.log('\n' + '='.repeat(50) + '\n');

  // Scraping i≈ülemi bittikten sonra veritabanƒ±na kayƒ±t i≈ülemini ba≈ülat
  exec('node scraper/save-to-db.js', (err, stdout, stderr) => {
    if (err) {
      console.error('Veritabanƒ± kaydƒ± ba≈ülatƒ±lamadƒ±:', err);
      return;
    }
    console.log(stdout);
    if (stderr) console.error(stderr);
  });
}

// üîÑ S√ºrekli tarama fonksiyonu
async function startContinuousScanning() {
  console.log('\n' + '='.repeat(50));
  console.log('üîÑ S√ºrekli Tarama Modu Ba≈ülatƒ±lƒ±yor');
  console.log('='.repeat(50));
  console.log(`\n‚è∞ Taramalar arasƒ± bekleme s√ºresi: ${SCAN_INTERVAL/1000/60} dakika\n`);

  while (true) {
    try {
      console.log('\n' + '='.repeat(50));
      console.log(`üïí Yeni tarama ba≈ülƒ±yor: ${new Date().toLocaleString()}`);
      console.log('='.repeat(50));

      await scrapeAll();

      console.log('\n' + '='.repeat(50));
      console.log(`‚è≥ Bir sonraki tarama i√ßin ${SCAN_INTERVAL/1000/60} dakika bekleniyor...`);
      console.log(`‚è∞ Sonraki tarama: ${new Date(Date.now() + SCAN_INTERVAL).toLocaleString()}`);
      console.log('='.repeat(50) + '\n');

      await new Promise(resolve => setTimeout(resolve, SCAN_INTERVAL));
    } catch (error) {
      console.error('\n‚ùå Tarama sƒ±rasƒ±nda hata olu≈ütu:', error);
      console.log(`\n‚è≥ Hata sonrasƒ± 5 dakika bekleniyor...`);
      await new Promise(resolve => setTimeout(resolve, 300000)); // 5 dakika bekle
    }
  }
}

// Ana fonksiyonu deƒüi≈ütir
startContinuousScanning(); // Yeni s√ºrekli tarama modu
